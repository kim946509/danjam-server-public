package com.example.danjamserver.notice.service.impl;import com.example.danjamserver.notice.domain.Notice;import com.example.danjamserver.notice.dto.FcmMessageDto;import com.example.danjamserver.notice.dto.FcmTokenDto;import com.example.danjamserver.notice.dto.FcmTokenSendDto;import com.example.danjamserver.notice.repository.NoticeRepository;import com.example.danjamserver.notice.service.FcmRestTokenService;import com.example.danjamserver.springSecurity.dto.CustomUserDetails;import com.example.danjamserver.user.domain.User;import com.example.danjamserver.user.repository.UserRepository;import com.example.danjamserver.util.exception.ResultCode;import com.example.danjamserver.util.response.RestResponse;import com.fasterxml.jackson.core.JsonProcessingException;import com.fasterxml.jackson.databind.ObjectMapper;import com.google.auth.oauth2.GoogleCredentials;import jakarta.persistence.EntityNotFoundException;import java.io.IOException;import java.nio.charset.StandardCharsets;import java.util.List;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.ClassPathResource;import org.springframework.http.HttpEntity;import org.springframework.http.HttpHeaders;import org.springframework.http.HttpMethod;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.http.converter.StringHttpMessageConverter;import org.springframework.stereotype.Service;import org.springframework.web.client.RestTemplate;@Service@Slf4j@RequiredArgsConstructorpublic class FcmRestTokenServiceImpl implements FcmRestTokenService {    private final NoticeRepository noticeRepository;    private final UserRepository userRepository;    @Value("${fcm.firebaseConfigPath}")    private String firebaseConfigPath;    /**     * 푸시 메시지 처리 수행 비즈니스 로직     *     * @param fcmTokenSendDto 모바일에서 전달받은 Object     * @return 성공(1), 실패(0)     */    @Override    public RestResponse<Object> sendMessageTo(FcmTokenSendDto fcmTokenSendDto) throws IOException {        String message = makeMessage(fcmTokenSendDto);        RestTemplate restTemplate = new RestTemplate();        //한글 깨짐 방지        restTemplate.getMessageConverters()                .add(0, new StringHttpMessageConverter(StandardCharsets.UTF_8));        HttpHeaders headers = new HttpHeaders();        headers.setContentType(MediaType.APPLICATION_JSON);        headers.set("Authorization", "Bearer " + getAccessToken());        HttpEntity entity = new HttpEntity<>(message, headers);        String API_URL = "https://fcm.googleapis.com/v1/projects/danjam-3ec61/messages:send";        ResponseEntity response = restTemplate.exchange(API_URL, HttpMethod.POST, entity, String.class);        System.out.println("fcm response getStatusCode: " + response.getStatusCode());        if (response.getStatusCode() == HttpStatus.OK) {            return RestResponse.success("메시지 전송 성공");        } else {            return RestResponse.error(ResultCode.INTERNAL_SERVER_ERROR, "메시지 전송 실패");        }    }    /**     * Firebase Admin SDK 의 비공개 키 참조 후, Bearer 토큰 발급 받음     *     * @return Bearer token     */    private String getAccessToken() throws IOException {        GoogleCredentials googleCredentials = GoogleCredentials                .fromStream(new ClassPathResource(firebaseConfigPath).getInputStream())                .createScoped(List.of("https://www.googleapis.com/auth/firebase.messaging")); //cloud-platform        googleCredentials.refreshIfExpired();        return googleCredentials.getAccessToken().getTokenValue();    }    /**     * FCM 전송 기반 메시지 구성 (Object -> String)     *     * @param fcmTokenSendDto     * @return String     */    private String makeMessage(FcmTokenSendDto fcmTokenSendDto) throws JsonProcessingException {        ObjectMapper om = new ObjectMapper();        FcmMessageDto fcmMessageDto = FcmMessageDto.builder()                .message(FcmMessageDto.Message.builder()                        .token(fcmTokenSendDto.getToken())                        .notification(FcmMessageDto.Notification.builder()                                .title(fcmTokenSendDto.getTitle())                                .body(fcmTokenSendDto.getBody())                                .build()).                        build()).validateOnly(false).build();        return om.writeValueAsString(fcmMessageDto);    }    /**     * FCM TOKEN 저장     *     * @return RestResponse<Obejec            * @ param1 customUserDetails            * @ param2 fcmTokenDto     */    @Override    public RestResponse<Object> saveFcmToken(CustomUserDetails customUserDetails, FcmTokenDto fcmTokenDto) {        Long userId = customUserDetails.getId();        String token = fcmTokenDto.getToken();        try {            // 기존에 저장된 FCM 토큰이 있는지 확인하고, 없으면 새로 저장            Notice existingNotice = noticeRepository.findByUserId(userId);            User user = userRepository.findById(Math.toIntExact(userId))                    .orElseThrow(() -> new EntityNotFoundException("유저가 존재하지 않습니다."));            if (existingNotice == null) {                Notice notice = Notice.builder()                        .user(user)                        .token(token)                        .build();                noticeRepository.save(notice);                return RestResponse.success("토큰 저장 성공");            } else {                existingNotice.setFcmToken(token);                noticeRepository.save(existingNotice);                return RestResponse.success("토큰 갱신 성공");            }        } catch (EntityNotFoundException e) {            return RestResponse.error(ResultCode.NO_MATCHING_USER_FOUND);        }    }}